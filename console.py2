#!/usr/bin/python
#
# TARDIS SFX module.
#
# Copyright (C) 2017-2018 Michael Thompson.  All Rights Reserved.
#
# Created 06-22-107 by Michael Thompson(triangletardis@gmail.com)
# Last modified 01-19-2019
#
# Version 3.0.2
#


from __future__ import division
import sys
import os
import signal
import time
import wave
import math
import contextlib
import evdev
import random
import pigpio


# Globals
#devName = "Compx 2.4G Receiver"
devName = "Logitech USB Receiver"
dirSound = "sound/"
pwmHz = 120
pwmSleepDefault = 0.010
pwmStep = 100
debug = False
autoPilot = False
bcmPin = 17
piGPIO = None


#
# Print a string to the console.
#
def conPrint(s):
   print("... \033[94m" + s + "\033[0m")


#
# Print a debug string to the console.
#
def debugPrint(s):
   if (debug):
      print("> \033[31;5m" + s + "\033[0m")


#
# Get length of a wave file.
#
def lenSound(f):
   debugPrint("Sound: " + f)
   with contextlib.closing(wave.open(dirSound + f, "r")) as w: 
      len = w.getnframes() / float(w.getframerate())
  
   debugPrint(" -- " + str(len) + " Seconds") 
   return len


#
# Play a wave file.
#
def playSound(f, secs=0, blk=False):
   debugPrint("Play: " + f)
   c = "aplay -q -N "

   if secs ==0 :
      c = c + (dirSound + f)
   else:
      c = c + "-d %s %s" % (secs, dirSound + f)

   if not blk:
      c = c + " &"

   debugPrint(c)
   os.system(c)


#
# Pulse Lights / Dematerialise effect.
#
def effectPulse(f, pwmSleep=pwmSleepDefault):
   conPrint("Pulse: " + f)
   len = lenSound(f)
   playSound(f)
    
   piGPIO.write(bcmPin, 1)
   piGPIO.set_PWM_frequency(bcmPin, pwmHz)
   piGPIO.set_PWM_range(bcmPin, 100)

   try:
      r = int(len / pwmSleep)
      debugPrint("T: " + str(r))
     
      for i in range(0,  r):
         l = int(pwmStep * 0.5 * ((math.cos((i / pwmStep) * 2 * math.pi)) + 1))
         #debugPrint("Level: " + str(l))
         piGPIO.set_PWM_dutycycle(bcmPin, l)
         time.sleep(pwmSleep)

      #Possibly wait out sound rounding error?
      #time.sleep(0.5)

   except Exception as e:
       print("Failed")
       print(e)
       pass
   
   conPrint("All Stop")
   piGPIO.set_PWM_dutycycle(bcmPin, 0)
   piGPIO.write(bcmPin, 1)


#
# Blink Lights / Door Lock effect.
#
def effectBlink(f):
   conPrint("Lock: " + f)
   len = lenSound(f)
   playSound(f)
    
   piGPIO.write(bcmPin, 1)
   piGPIO.set_PWM_frequency(bcmPin, pwmHz)
   piGPIO.set_PWM_range(bcmPin, 100)

   try:
      for l in [100, 0, 25, 100, 0, 25, 100]:
         debugPrint("Level: " + str(l))
         piGPIO.set_PWM_dutycycle(bcmPin, l)
         time.sleep(0.1)

   except Exception as e:
       print("Failed")
       print(e)
       pass
   
   conPrint("Locked")
   piGPIO.set_PWM_dutycycle(bcmPin, 0)
   piGPIO.write(bcmPin, 1)


#
# Signal Handler.
#
def sig_handler(signal, frame):
   conPrint("Emergency Exit")
   piGPIO.stop()
   sys.exit(1)


#
# Main
#
autoPilot = len(sys.argv) > 1
os.system("./console_init_3.sh")
conPrint("*****")
conPrint("Console Enabled")

#Init GPIO
signal.signal(signal.SIGINT, sig_handler)
piGPIO = pigpio.pi()
piGPIO.write(bcmPin, 1)

if autoPilot:
   conPrint("Auto Pilot")
   gp = evdev.InputDevice("/dev/input/event0")
   gp.write(evdev.ecodes.EV_KEY, evdev.ecodes.KEY_LEFTSHIFT, 1)
else:
   conPrint("Locate Registered Operator")
   #playSound("runaway_scanning.wav", 5, True)
   devices = [evdev.InputDevice(fn) for fn in evdev.list_devices()]
   gp = None

   for device in devices:
      conPrint("Device: " + device.name + " [" + device.fn + "]")

      if (device.name == devName):
         gp = evdev.InputDevice(device.fn)
         conPrint("Found Operator!")
         break

if not autoPilot and (gp is None):
   conPrint("Operator Missing!")
else:
    for event in gp.read_loop():
      if event.type == evdev.ecodes.EV_KEY or event.type == evdev.ecodes.EV_REL:
         keyevent = evdev.categorize(event)
         ranEvent = True

         if event.type == evdev.ecodes.EV_KEY and keyevent.keystate == evdev.events.KeyEvent.key_down:
            kCode = keyevent.keycode[0] if type(keyevent.keycode) is list else keyevent.keycode
         elif event.code == evdev.ecodes.REL_WHEEL:
            kCode = "UP" if event.value == 1 else "DOWN"
         else:
            kCode = None
         
         if autoPilot:
            foo = ['UP', 'BTN_MIDDLE', 'BTN_LEFT', 'BTN_RIGHT', 'DOWN']
            kCode = random.choice(foo)

         if kCode != None:
            debugPrint("KEY: " + kCode)

         if kCode == "BTN_LEFT":
            effectPulse("takeoff.wav", pwmSleepDefault * 2)
         elif kCode == "BTN_MIDDLE":
            effectBlink("lock_chirp.wav")
         elif kCode == "BTN_RIGHT":
            effectPulse("exterior_telephone.wav", pwmSleepDefault * 0.5)
         elif kCode == "UP":
            effectPulse("cloister_bell.wav", pwmSleepDefault * 3)
         elif kCode == "DOWN":
            effectPulse("denied_takeoff.wav", pwmSleepDefault * 1.5)
         else:
            ranEvent = False

         if ranEvent:
            while gp.read_one() != None:
               pass

         piGPIO.write(bcmPin, 1)

         if autoPilot:
            gp.write(evdev.ecodes.EV_KEY, evdev.ecodes.KEY_LEFTSHIFT, 0)
            gp.write(evdev.ecodes.EV_KEY, evdev.ecodes.KEY_LEFTSHIFT, 1)
            r = (random.randint(1,5) * 1000) + 5000
            conPrint("Wait: " + str(r))
            time.sleep(r)


# Finish
piGPIO.write(bcmPin, 1)
piGPIO.stop()
conPrint("Safe Exit")
