#!/usr/bin/python
#
# TARDIS SFX module.
#
# Copyright (C) 2017-2019 Michael Thompson.  All Rights Reserved.
#
# Created 06-22-2017 by Michael Thompson(triangletardis@gmail.com)
# Last modified 01-20-2019
#
# Version 3.0.3
#


from __future__ import division
import sys
import os
import signal
import time
import wave
import math
import contextlib
import evdev
import random
import pigpio


# Globals
#devName = "Compx 2.4G Receiver"
devName = "Logitech USB Receiver"
dirSound = "sound/"
pwmHz = 120
pwmSleepDefault = 0.010
pwmStep = 100
debug = False
autoPilot = False
bcmPin = 17
piGPIO = None


#
# Print a string to the console.
#
def conPrint(s):
   print("... \033[94m" + s + "\033[0m")


#
# Print a debug string to the console.
#
def debugPrint(s):
   if (debug):
      print("> \033[31;5m" + s + "\033[0m")


#
# Get length of a wave file.
#
def lenSound(f):
   debugPrint("Sound: " + f)
   with contextlib.closing(wave.open(dirSound + f, "r")) as w: 
      len = w.getnframes() / float(w.getframerate())
  
   debugPrint(" -- " + str(len) + " Seconds") 
   return len


#
# Play a wave file.
#
def playSound(f, secs=0, blk=False):
   debugPrint("Play: " + f)
   c = "aplay -q -N "

   if secs ==0 :
      c = c + (dirSound + f)
   else:
      c = c + "-d %s %s" % (secs, dirSound + f)

   if not blk:
      c = c + " &"

   debugPrint(c)
   os.system(c)


#
# Pulse Lights / Dematerialise effect.
#
def effectPulse(f, pwmSleep=pwmSleepDefault):
   conPrint("Pulse: " + f)
   len = lenSound(f)
   playSound(f)
    
   piGPIO.write(bcmPin, 1)
   piGPIO.set_PWM_frequency(bcmPin, pwmHz)
   piGPIO.set_PWM_range(bcmPin, 100)

   try:
      r = int(len / pwmSleep)
      debugPrint("T: " + str(r))
     
      for i in range(0,  r):
         l = int(pwmStep * 0.5 * ((math.cos((i / pwmStep) * 2 * math.pi)) + 1))
         #debugPrint("Level: " + str(l))
         piGPIO.set_PWM_dutycycle(bcmPin, l)
         time.sleep(pwmSleep)

      #Possibly wait out sound rounding error?
      #time.sleep(0.5)

   except Exception as e:
       print("Failed")
       print(e)
   
   conPrint("All Stop")
   piGPIO.set_PWM_dutycycle(bcmPin, 0)
   piGPIO.write(bcmPin, 1)


#
# Blink Lights / Door Lock effect.
#
def effectBlink(f):
   conPrint("Lock: " + f)
   len = lenSound(f)
   playSound(f)
    
   piGPIO.write(bcmPin, 1)
   piGPIO.set_PWM_frequency(bcmPin, pwmHz)
   piGPIO.set_PWM_range(bcmPin, 100)

   try:
      for l in [100, 0, 25, 100, 0, 25, 100]:
         #debugPrint("Level: " + str(l))
         piGPIO.set_PWM_dutycycle(bcmPin, l)
         time.sleep(0.1)

   except Exception as e:
       print("Failed")
       print(e)
   
   conPrint("Locked")
   piGPIO.set_PWM_dutycycle(bcmPin, 0)
   piGPIO.write(bcmPin, 1)


#
# Signal Handler.
#
def sig_handler(signal, frame):
   conPrint("Emergency Exit")
   piGPIO.stop()

   if gp != None:
      gp.ungrab()

   sys.exit(1)


#
# Main
#
autoPilot = len(sys.argv) > 1
os.system("./console_init_3.sh")
conPrint("***** Console Enabled *****")

#Init GPIO
signal.signal(signal.SIGINT, sig_handler)
piGPIO = pigpio.pi()
piGPIO.set_mode(bcmPin, pigpio.OUTPUT)
piGPIO.write(bcmPin, 1)

#Find Input Device
conPrint("Locate Registered Operator")
#playSound("runaway_scanning.wav", 5, True)
devices = [evdev.InputDevice(fn) for fn in evdev.list_devices()]
gp = None

for device in devices:
   conPrint("Device: " + device.name + " [" + device.fn + "]")

   #if evdev.ecodes.EV_ABS in device.capabilities():
   if (device.name == devName):
      gp = evdev.InputDevice(device.fn)
      break

if autoPilot and (gp is None):
   gp = evdev.InputDevice("/dev/input/event0")

#Event Loop
if not autoPilot and (gp is None):
   conPrint("Operator Missing!")
else:
   conPrint("Found Operator!  [" + gp.name + "] (Autopilot: " + str(autoPilot) + ")")
   gp.grab()
   r = 0
   rf = 0

   while True:
      time.sleep(0.01)
      ranEvent = False
      event = gp.read_one()

      #Autopilot Injects Events periodically
      if autoPilot:
          if (r >= rf):
            r = 0
            rf = (random.randint(10,60)) * 100
            conPrint("Next Wait: " + str(rf))
            event = evdev.events.InputEvent(0, 0, evdev.ecodes.EV_KEY, evdev.ecodes.KEY_ESC, 1)
 
      #Handle Event
      if (event != None) and (event.type == evdev.ecodes.EV_KEY or event.type == evdev.ecodes.EV_REL):
         keyevent = evdev.categorize(event)
         kCode = None
         debugPrint("EVENT: " + str(keyevent))
         
         if (autoPilot and r == 0):
            conPrint("Automatic action")
            kCode = random.choice(["UP", "BTN_MIDDLE", "BTN_LEFT", "BTN_RIGHT", "DOWN"])
         else:
            #Handle multiple key press and convert mouse wheel axis to single press
            if event.type == evdev.ecodes.EV_KEY and keyevent.keystate == evdev.events.KeyEvent.key_down:
               kCode = keyevent.keycode[0] if type(keyevent.keycode) is list else keyevent.keycode
            elif event.code == evdev.ecodes.REL_WHEEL:
               kCode = "UP" if event.value == 1 else "DOWN"

         if kCode != None:
            r = 0
            debugPrint("KEY: " + kCode)

         #Run Effect
         if kCode == "BTN_LEFT":
            effectPulse("takeoff.wav", pwmSleepDefault * 2)
            ranEvent = True
         elif kCode == "BTN_MIDDLE":
            effectBlink("lock_chirp.wav")
            ranEvent = True
         elif kCode == "BTN_RIGHT":
            effectPulse("exterior_telephone.wav", pwmSleepDefault * 0.5)
            ranEvent = True
         elif kCode == "UP":
            effectPulse("cloister_bell.wav", pwmSleepDefault * 3)
            ranEvent = True
         elif kCode == "DOWN":
            effectPulse("denied_takeoff.wav", pwmSleepDefault * 1.5)
            ranEvent = True
         elif kCode != None:
            debugPrint("Unused Key: " + str(kCode))

         #Empty Input Buffer
         if ranEvent:
            while gp.read_one() != None:
               #sys.stdout.write("%")
               pass
            #sys.stdout.write("\n\n")

         piGPIO.write(bcmPin, 1)
      #endif

      r += 1
   #endWhile

# Finish
piGPIO.write(bcmPin, 1)
piGPIO.stop()
conPrint("Safe Exit")

if gp != None:
   gp.ungrab()
